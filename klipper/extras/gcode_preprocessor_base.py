# G-code Preprocessor Base Classes

import re
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Tuple


class PreprocessorContext:
    """Context object passed to preprocessors containing file and printer state"""

    def __init__(self):
        self.file_path: str = ""
        self.filename: str = ""
        self.metadata: Dict[str, Any] = {}
        self.toolchanger_config: Dict[str, Any] = {}
        self.tools: List[int] = []
        self.current_line: int = 0
        self.total_lines: int = 0

    def set_metadata(self, key: str, value: Any):
        """Store metadata for other processors to use"""
        self.metadata[key] = value

    def get_metadata(self, key: str, default: Any = None) -> Any:
        """Retrieve metadata stored by other processors"""
        return self.metadata.get(key, default)


class GcodePreprocessorPlugin(ABC):
    """Abstract base class for G-code preprocessor plugins"""

    def __init__(self, config, logger):
        """
        Initialize the preprocessor plugin

        Args:
            config: Configuration dictionary for this processor
            logger: Logger instance for output
        """
        self.config = config
        self.logger = logger
        self.enabled = config.get('enabled', True)
        self.priority = config.get('priority', 50)
        self.name = self.__class__.__name__

    @abstractmethod
    def get_name(self) -> str:
        """Return the name of this processor"""
        pass

    @abstractmethod
    def get_description(self) -> str:
        """Return a description of what this processor does"""
        pass

    def can_process(self, file_path: str, context: PreprocessorContext) -> bool:
        """
        Determine if this processor should run on the given file

        Args:
            file_path: Path to the G-code file
            context: Preprocessing context

        Returns:
            True if this processor should run, False otherwise
        """
        return self.enabled

    def pre_process(self, file_path: str, context: PreprocessorContext) -> bool:
        """
        Initial pass through the file before line-by-line processing
        Use this to gather metadata, build usage maps, etc.

        Args:
            file_path: Path to the G-code file
            context: Preprocessing context

        Returns:
            True if successful, False on error
        """
        return True

    @abstractmethod
    def process_line(self, line: str, context: PreprocessorContext) -> List[str]:
        """
        Process a single line of G-code

        Args:
            line: The G-code line to process
            context: Preprocessing context

        Returns:
            List of lines to output (can be empty, one, or multiple lines)
            Return [line] to keep the line unchanged
        """
        pass

    def post_process(self, file_path: str, context: PreprocessorContext) -> bool:
        """
        Final pass after all line processing is complete
        Use this for finalization, summary generation, etc.

        Args:
            file_path: Path to the G-code file
            context: Preprocessing context

        Returns:
            True if successful, False on error
        """
        return True


class GcodePatterns:
    """Common regex patterns for G-code parsing"""

    # Tool change patterns
    T_COMMAND = re.compile(r'^T(\d+)\s*(?:;.*)?$', re.IGNORECASE)
    SELECT_TOOL = re.compile(r'^SELECT_TOOL\s+(?:TOOL=(\w+)|T=(\d+))', re.IGNORECASE)
    MMU_CHANGE_TOOL = re.compile(r'^MMU_CHANGE_TOOL(?:_STANDALONE)?\s+TOOL=(\d+)', re.IGNORECASE)

    # Temperature commands
    M104 = re.compile(r'^M104\s+(?:T(\d+)\s+)?S([\d.]+)', re.IGNORECASE)
    M109 = re.compile(r'^M109\s+(?:T(\d+)\s+)?S([\d.]+)', re.IGNORECASE)
    SET_TOOL_TEMP = re.compile(r'^SET_TOOL_TEMPERATURE\s+(?:TOOL=(\w+)|T=(\d+))\s+TARGET=([\d.]+)', re.IGNORECASE)

    # Movement commands
    G0_G1 = re.compile(r'^G[01]\s+', re.IGNORECASE)
    G0_G1_XY = re.compile(r'^G[01](?=.*\sX([-\d.]+))(?=.*\sY([-\d.]+)).*$', re.IGNORECASE)

    # Slicer metadata comments
    SLICER_NAME = re.compile(r'^;.*generated by ([a-z]*) .*$|^; (BambuStudio) .*$', re.IGNORECASE)
    EXTRUDER_COLOR = re.compile(r'^;\s*(?:extruder|filament)_colour\s*=\s*(#.*;*.*)$', re.IGNORECASE)
    FILAMENT_TYPE = re.compile(r'^;\s*filament_type\s*=\s*(.*)$', re.IGNORECASE)
    TEMPERATURE = re.compile(r'^;\s*(?:nozzle_)?temperature\s*=\s*(.*)$', re.IGNORECASE)
    PURGE_VOLUMES = re.compile(r'^;\s*(?:flush_volumes_matrix|wiping_volumes_matrix)\s*=\s*(.*)$', re.IGNORECASE)
    FILAMENT_NAMES = re.compile(r'^;\s*filament_settings_id\s*=\s*(.*)$', re.IGNORECASE)

    # Placeholder patterns
    PLACEHOLDER = re.compile(r'!(\w+)!')

    @staticmethod
    def is_comment(line: str) -> bool:
        """Check if a line is a comment"""
        return line.strip().startswith(';')

    @staticmethod
    def is_empty(line: str) -> bool:
        """Check if a line is empty or whitespace only"""
        return len(line.strip()) == 0

    @staticmethod
    def strip_comment(line: str) -> Tuple[str, str]:
        """
        Split a line into command and comment parts

        Returns:
            Tuple of (command, comment) where comment includes the ';'
        """
        if ';' in line:
            parts = line.split(';', 1)
            return parts[0].rstrip(), ';' + parts[1]
        return line.rstrip(), ''

    @staticmethod
    def extract_tool_number(line: str) -> Optional[int]:
        """
        Extract tool number from any tool change command

        Returns:
            Tool number or None if not a tool change command
        """
        # Try T command
        match = GcodePatterns.T_COMMAND.match(line)
        if match:
            return int(match.group(1))

        # Try SELECT_TOOL
        match = GcodePatterns.SELECT_TOOL.match(line)
        if match:
            if match.group(2):  # T=N format
                return int(match.group(2))

        # Try MMU_CHANGE_TOOL
        match = GcodePatterns.MMU_CHANGE_TOOL.match(line)
        if match:
            return int(match.group(1))

        return None


class PreprocessorUtilities:
    """Utility functions for preprocessors"""

    @staticmethod
    def read_file_lines(file_path: str) -> List[str]:
        """Read all lines from a file, preserving line endings"""
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            return f.readlines()

    @staticmethod
    def write_file_lines(file_path: str, lines: List[str]):
        """Write lines to a file"""
        with open(file_path, 'w', encoding='utf-8') as f:
            f.writelines(lines)

    @staticmethod
    def format_tool_temp_command(tool_number: int, temperature: float) -> str:
        """Format a tool temperature command"""
        return f"M104 T{tool_number} S{temperature}\n"

    @staticmethod
    def parse_csv_list(csv_string: str, strip_chars: str = '#') -> List[str]:
        """Parse a semicolon or comma separated list"""
        items = []
        for separator in [';', ',']:
            if separator in csv_string:
                items = [item.strip().lstrip(strip_chars) for item in csv_string.split(separator)]
                break
        return items if items else [csv_string.strip().lstrip(strip_chars)]

    @staticmethod
    def add_fingerprint(slicer: Optional[str] = None) -> str:
        """Generate a fingerprint comment for preprocessed files"""
        if slicer:
            return f"; processed by toolchanger_preprocessor (slicer: {slicer})\n"
        return "; processed by toolchanger_preprocessor\n"
